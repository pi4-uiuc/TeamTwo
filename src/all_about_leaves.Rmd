---
title: "All About Leaves"
output: html_notebook
---

Let's load up the 67 leaf-related variables we're going to explore:

```{r}
library(traits)
library(dplyr)

options(#betydb_key = readLines('~/.betykey', warn = FALSE),
  betydb_url = "https://betydb.org",
  betydb_api_version = 'beta')

leaf_variables <- betydb_query(table = "variables", limit = 'none') %>%    # Should take about 15 seconds
  mutate(variable_id = id) %>%    # We're going to need to be joining based on variable_id later
  select(variable_id, description, name, units) %>%    # Only care about the important stuff
  filter(grepl("leaf",name)) %>%    # Only those variables with "leaf" in the name
  collect()

```

And a sufficiently large table of measurements of said variables:

```{r}

leaf_traits_bare <- betydb_query(table = "traits", limit = 'none') %>%    # Should take about 70 seconds
  inner_join(leaf_variables, by = "variable_id") %>%
  select(name, mean, units, description, date, specie_id, site_id, treatment_id)

```

Let's hook leaf_traits up to the species table:

```{r}

species <- betydb_query(table = "species", limit = 'none') %>%    ## I believe there are 70529 distinct species total; this takes around 10 minutes
  mutate(specie_id = id)

leaf_traits <- leaf_traits_bare %>%
  left_join(species, by = "specie_id") %>%
  filter(!is.na(scientificname)) %>%    # For some reason there are a lot of specie_id values not found in the species table...
  select(name, mean, units, description, date, specie_id, scientificname, commonname, site_id, treatment_id)


```

Now we're cooking with gas. Some of the species and variables are rather obscure, though (in fact only 21 of the 67 leaf-related variables are populated at all, by my count), so let's see which species have had the most unique variables measured, and which variables have been measured across the widest range of species:

```{r}

traits_ranking <- leaf_traits %>%
  group_by(name) %>%
  mutate(species_with_trait = length(unique(scientificname))) %>%
  select(name, species_with_trait) %>%
  unique

species_ranking <- leaf_traits %>%
  group_by(scientificname) %>%
  mutate(traits_of_species = length(unique(name))) %>%
  select(scientificname, commonname, traits_of_species) %>%
  unique

```

It appears there are only 9 leaf variables that have been measured across 10+ species, and only 48 species have had 3+ unique leaf variables measured. Concerning ourselves only with these important species and variables, why not build a support vector machine that can predict which species a plant is, given one or more measurements of its leaves?

```{r}

important_species <- species_ranking %>%
  filter(traits_of_species >= 3) %>%
  select(scientificname) %>%
  collect()

important_traits <- traits_ranking %>%
  filter(species_with_trait >= 10) %>%
  select(name) %>%
  collect()

important_species = as.vector(important_species$scientificname)
important_traits = as.vector(important_traits$name)
print(important_species)
print(important_traits)
important_leaf_traits <- leaf_traits %>%
  filter((name %in% important_traits) & (scientificname %in% important_species)) %>%
  select(scientificname, name, mean) %>%
  group_by(scientificname, name) %>%
  mutate(supermean = mean(mean)) %>%
  select(scientificname, name, supermean) %>%
  unique

#The below code accomplishes what the for loop is intended to accomplish.

install.packages('reshape2')
library(reshape2)
organized_important_leaf_traits <- dcast(important_leaf_traits, scientificname ~ name, value.var="supermean")

 

#final_table <- data.frame(matrix(ncol = length(important_traits)+1, nrow = length(important_species)))

#colnames(final_table) <- c("Species",important_traits)

#final_table[,1]<-important_species

#for(rowIndex in 1:length(important_species)){
    #curSpecies <- important_species[rowIndex]
  #for(colIndex in 1:length(important_traits)){
    #curTrait <- important_traits[colIndex]
    #filtered = important_leaf_traits %>% filter((scientificname == curSpecies) & (name == curTrait))
    #if(nrow(filtered) == 1){
      #final_table[rowIndex,colIndex+1] = filtered[1,3]
    #}
  #}
#}



# First we pare down our leaf_traits so that it only concerns important species and variables

# Then we read these measurements and produce a table with 8 columns (leaf variables) and 48 rows (species), taking the mean (median?) where a specific variable has been measured on a specific species multiple times

# Then we fill in NA entries with gross column means (this will both allow the SVM to work, but also possibly bias the SVM to favoritize classifications of species with many NA values relative to the measurements inputted; if this becomes an issue, we could mitigate it via a "master predictor" which, given m < 8 leaf measurements, builds an SVM from only those m columns and applies it to the input)

# Then we build an SVM that will classify based on these rows. Since there are only as many "observations" as classes, this should be equivalent to 1-nearest-neighbor prediction.

```
